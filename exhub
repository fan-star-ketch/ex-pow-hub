-- Test Exploit Panel (upgraded, mobile-focused)
-- Put this as a LocalScript in StarterGui (ONLY use in your own place for testing)

-- SERVICES
local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local RS = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Camera = workspace.CurrentCamera

-- PLAYER/CHAR
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid") or character:WaitForChild("Humanoid")

-- handle respawn
local function onCharacterAdded(char)
	character = char
	humanoid = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid")
end
player.CharacterAdded:Connect(onCharacterAdded)

-- SETTINGS
local DEFAULT_SPEED = 16
local MAX_SPEED = 200
local DEFAULT_JUMP = 50
local MAX_JUMP = 300

-- UI BASE
local gui = Instance.new("ScreenGui")
gui.Name = "SX_TestExploitPanel"
gui.ResetOnSpawn = false
gui.Parent = playerGui

-- main container (mobile-friendly big size)
local frame = Instance.new("Frame")
frame.Name = "Main"
frame.Size = UDim2.new(0, 390, 0, 520)
frame.Position = UDim2.new(0.5, -195, 0.5, -260)
frame.AnchorPoint = Vector2.new(0.5,0.5)
frame.BackgroundColor3 = Color3.fromRGB(18,18,22)
frame.BorderSizePixel = 0
frame.Parent = gui
frame.Active = true -- allow input
local frameCorner = Instance.new("UICorner", frame)
frameCorner.CornerRadius = UDim.new(0, 12)

-- title bar (draggable)
local titleBar = Instance.new("Frame", frame)
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1,0,0,44)
titleBar.Position = UDim2.new(0,0,0,0)
titleBar.BackgroundColor3 = Color3.fromRGB(12,12,14)
local titleCorner = Instance.new("UICorner", titleBar); titleCorner.CornerRadius = UDim.new(0,12)

local titleText = Instance.new("TextLabel", titleBar)
titleText.Size = UDim2.new(1,-88,1,0)
titleText.Position = UDim2.new(0,12,0,0)
titleText.BackgroundTransparency = 1
titleText.Text = "SX â€” Exploit Test Panel"
titleText.TextColor3 = Color3.fromRGB(230,230,230)
titleText.Font = Enum.Font.GothamBold
titleText.TextSize = 18
titleText.TextXAlignment = Enum.TextXAlignment.Left

local closeBtn = Instance.new("TextButton", titleBar)
closeBtn.Size = UDim2.new(0,64,0,36)
closeBtn.Position = UDim2.new(1,-74,0,4)
closeBtn.BackgroundColor3 = Color3.fromRGB(40,40,44)
closeBtn.Text = "CLOSE"
closeBtn.Font = Enum.Font.GothamBold
closeBtn.TextSize = 13
closeBtn.TextColor3 = Color3.fromRGB(240,240,240)
local closeCorner = Instance.new("UICorner", closeBtn); closeCorner.CornerRadius = UDim.new(0,8)

local toggleBtn = Instance.new("TextButton", titleBar)
toggleBtn.Size = UDim2.new(0,44,0,36)
toggleBtn.Position = UDim2.new(1,-140,0,4)
toggleBtn.BackgroundColor3 = Color3.fromRGB(0,150,255)
toggleBtn.Text = "S"
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextSize = 18
toggleBtn.TextColor3 = Color3.fromRGB(255,255,255)
local toggleCorner = Instance.new("UICorner", toggleBtn); toggleCorner.CornerRadius = UDim.new(0,8)

-- scroll area for many controls
local scroller = Instance.new("ScrollingFrame", frame)
scroller.Size = UDim2.new(1,-24,1,-64)
scroller.Position = UDim2.new(0,12,0,52)
scroller.CanvasSize = UDim2.new(0,0,0,1400)
scroller.ScrollBarThickness = 12
scroller.BackgroundTransparency = 1

-- small helper to create sections
local function sectionHeader(parent, text, y)
	local h = Instance.new("TextLabel", parent)
	h.Size = UDim2.new(1, -20, 0, 26)
	h.Position = UDim2.new(0,10,0,y)
	h.BackgroundTransparency = 1
	h.Font = Enum.Font.GothamBold
	h.TextSize = 15
	h.TextColor3 = Color3.fromRGB(220,220,220)
	h.Text = text
	h.TextXAlignment = Enum.TextXAlignment.Left
	return h
end

local function makeButton(parent, text, y)
	local b = Instance.new("TextButton", parent)
	b.Size = UDim2.new(1,-20,0,44)
	b.Position = UDim2.new(0,10,0,y)
	b.BackgroundColor3 = Color3.fromRGB(36,36,40)
	b.Font = Enum.Font.GothamBold
	b.TextSize = 16
	b.TextColor3 = Color3.fromRGB(240,240,240)
	b.Text = text
	local c = Instance.new("UICorner", b); c.CornerRadius = UDim.new(0,8)
	return b
end

local function makeToggle(parent, text, y)
	local lbl = Instance.new("Frame", parent)
	lbl.Size = UDim2.new(1,-20,0,44)
	lbl.Position = UDim2.new(0,10,0,y)
	lbl.BackgroundColor3 = Color3.fromRGB(26,26,30)
	local c = Instance.new("UICorner", lbl); c.CornerRadius = UDim.new(0,8)

	local t = Instance.new("TextLabel", lbl)
	t.Size = UDim2.new(0.7, -8, 1, 0)
	t.Position = UDim2.new(0,12,0,0)
	t.BackgroundTransparency = 1
	t.Font = Enum.Font.GothamBold
	t.TextSize = 15
	t.TextColor3 = Color3.fromRGB(220,220,220)
	t.Text = text
	t.TextXAlignment = Enum.TextXAlignment.Left

	local btn = Instance.new("TextButton", lbl)
	btn.Size = UDim2.new(0,80,0,30)
	btn.Position = UDim2.new(1,-92,0.5,-15)
	btn.BackgroundColor3 = Color3.fromRGB(75,75,80)
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 14
	btn.TextColor3 = Color3.fromRGB(240,240,240)
	btn.Text = "OFF"
	local bc = Instance.new("UICorner", btn); bc.CornerRadius = UDim.new(0,6)

	return {frame = lbl, label = t, button = btn}
end

local function makeSlider(parent, labelText, y, min, max, default)
	local cont = Instance.new("Frame", parent)
	cont.Size = UDim2.new(1,-20,0,80)
	cont.Position = UDim2.new(0,10,0,y)
	cont.BackgroundTransparency = 1

	local lbl = Instance.new("TextLabel", cont)
	lbl.Size = UDim2.new(1,0,0,20)
	lbl.Position = UDim2.new(0,0,0,0)
	lbl.BackgroundTransparency = 1
	lbl.Font = Enum.Font.GothamBold
	lbl.TextSize = 14
	lbl.TextColor3 = Color3.fromRGB(220,220,220)
	lbl.Text = labelText
	lbl.TextXAlignment = Enum.TextXAlignment.Left

	local bar = Instance.new("Frame", cont)
	bar.Size = UDim2.new(1,0,0,12)
	bar.Position = UDim2.new(0,0,0,28)
	bar.BackgroundColor3 = Color3.fromRGB(48,48,56)
	local bc = Instance.new("UICorner", bar); bc.CornerRadius = UDim.new(1,0)

	local fill = Instance.new("Frame", bar)
	fill.Size = UDim2.new((default - min) / (max - min), 0, 1, 0)
	fill.BackgroundColor3 = Color3.fromRGB(0,150,255)
	local fc = Instance.new("UICorner", fill); fc.CornerRadius = UDim.new(1,0)

	local knob = Instance.new("ImageButton", bar)
	knob.Size = UDim2.new(0,30,0,30)
	knob.AnchorPoint = Vector2.new(0.5,0.5)
	knob.Position = UDim2.new(fill.Size.X.Scale, 0, 0.5, 0)
	knob.BackgroundTransparency = 1

	local valLabel = Instance.new("TextLabel", cont)
	valLabel.Size = UDim2.new(1,0,0,20)
	valLabel.Position = UDim2.new(0,0,0,48)
	valLabel.BackgroundTransparency = 1
	valLabel.Font = Enum.Font.GothamBold
	valLabel.TextSize = 14
	valLabel.TextColor3 = Color3.fromRGB(210,210,210)
	valLabel.Text = tostring(default)

	-- interactive logic (touch + mouse)
	local dragging = false
	local function setFromX(x)
		local p = math.clamp((x - bar.AbsolutePosition.X) / bar.AbsoluteSize.X, 0, 1)
		fill.Size = UDim2.new(p,0,1,0)
		knob.Position = UDim2.new(p,0,0.5,0)
		local value = math.floor(min + (max - min) * p + 0.5)
		valLabel.Text = tostring(value)
		return value, p
	end

	knob.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
		end
	end)
	bar.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			setFromX(input.Position.X)
			dragging = true
		end
	end)
	UIS.InputChanged:Connect(function(input)
		if not dragging then return end
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			setFromX(input.Position.X)
		end
	end)
	UIS.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = false
		end
	end)

	-- convert current displayed to numeric
	local function getValue()
		return tonumber(valLabel.Text) or default
	end

	return {container = cont, setFromX = setFromX, getValue = getValue, valLabel = valLabel}
end

-- Build UI sections & many features
local y = 8
sectionHeader(scroller, "Movement", y); y = y + 28

local walkSlider = makeSlider(scroller, "WalkSpeed (live)", y, 0, MAX_SPEED, DEFAULT_SPEED); y = y + 90
local jumpSlider = makeSlider(scroller, "JumpPower (live)", y, 0, MAX_JUMP, DEFAULT_JUMP); y = y + 90

local flyToggle = makeToggle(scroller, "Fly (hold directional)", y); y = y + 54
local noclipToggle = makeToggle(scroller, "Noclip (pass through colliders)", y); y = y + 54
local infJumpToggle = makeToggle(scroller, "Infinite Jump", y); y = y + 54

sectionHeader(scroller, "Teleport & Movement Tests", y); y = y + 28
local tpUpBtn = makeButton(scroller, "Teleport Up 50", y); y = y + 50
local tpMouseBtn = makeButton(scroller, "Teleport To Cursor/Touch", y); y = y + 50
local tpNearestBtn = makeButton(scroller, "Teleport To Nearest Player", y); y = y + 50

sectionHeader(scroller, "Remote & Spam Tests", y); y = y + 28
local remoteFireBtn = makeButton(scroller, "Spam RemoteEvent (ExploitTestEvent)", y); y = y + 50
local remoteBurstBtn = makeButton(scroller, "Burst Remote (50x)", y); y = y + 50

sectionHeader(scroller, "Misc / Debug", y); y = y + 28
local sitBtn = makeButton(scroller, "Sit / Unsit", y); y = y + 50
local regenBtn = makeButton(scroller, "Heal to Full", y); y = y + 50
local gravityBtn = makeButton(scroller, "Toggle Low Gravity (0.5x)", y); y = y + 50
local fpsTeleportBtn = makeButton(scroller, "Blink Teleport (Forward 10)", y); y = y + 50
local anticheckBtn = makeButton(scroller, "Print Local AntiCheat Flags", y); y = y + 50

sectionHeader(scroller, "Quick Presets", y); y = y + 28
local preset1 = makeButton(scroller, "Speedy (100) / Jump 100", y); y = y + 50
local preset2 = makeButton(scroller, "Moon (Speed 50 Jump 200)", y); y = y + 50
local resetAll = makeButton(scroller, "Reset All Client Changes", y); y = y + 50

-- Small helper variables/state
local state = {
	flying = false,
	noclip = false,
	infJump = false,
	lowGravity = false,
	gravityPrev = workspace.Gravity,
	flyVelocity = Vector3.new(0,0,0),
	touchUp = false,
	touchDown = false,
}

-- LIVE sliders binding
-- Update humanoid properties live (client-side)
RS.Heartbeat:Connect(function()
	-- ensure humanoid reference valid
	if not humanoid or not humanoid.Parent then
		local char = player.Character
		if char then
			humanoid = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid")
		end
	end

	-- set walk/jump values from sliders
	if humanoid and humanoid.Parent then
		local ws = tonumber(walkSlider.getValue and walkSlider.getValue() or walkSlider.getValue) or tonumber(walkSlider.valLabel.Text) or DEFAULT_SPEED
		local jp = tonumber(jumpSlider.getValue and jumpSlider.getValue() or jumpSlider.getValue) or tonumber(jumpSlider.valLabel.Text) or DEFAULT_JUMP
		-- safe pcall
		pcall(function()
			humanoid.WalkSpeed = math.clamp(ws, 0, MAX_SPEED)
			humanoid.JumpPower = math.clamp(jp, 0, MAX_JUMP)
		end)
	end
end)

-- Helper: find nearest player
local function nearestPlayer()
	local best, bestDist = nil, math.huge
	if not character or not character.PrimaryPart then return nil end
	for _, pl in pairs(Players:GetPlayers()) do
		if pl ~= player and pl.Character and pl.Character.PrimaryPart then
			local d = (pl.Character.PrimaryPart.Position - character.PrimaryPart.Position).Magnitude
			if d < bestDist then bestDist, best = d, pl end
		end
	end
	return best
end

-- FLY implementation works with WASD on PC and MoveDirection on mobile.
local flyConn
local function startFly()
	if state.flying then return end
	state.flying = true
	-- create BodyVelocity-like behaviour by translating character each frame
	flyConn = RS.RenderStepped:Connect(function(dt)
		if not character or not character.PrimaryPart then return end
		local root = character.PrimaryPart
		local dir = Vector3.new(0,0,0)
		-- PC keys
		if UIS:IsKeyDown(Enum.KeyCode.W) then dir = dir + Vector3.new(0,0,-1) end
		if UIS:IsKeyDown(Enum.KeyCode.S) then dir = dir + Vector3.new(0,0,1) end
		if UIS:IsKeyDown(Enum.KeyCode.A) then dir = dir + Vector3.new(-1,0,0) end
		if UIS:IsKeyDown(Enum.KeyCode.D) then dir = dir + Vector3.new(1,0,0) end
		if UIS:IsKeyDown(Enum.KeyCode.Space) then dir = dir + Vector3.new(0,1,0) end
		if UIS:IsKeyDown(Enum.KeyCode.LeftShift) then dir = dir + Vector3.new(0,-1,0) end

		-- mobile: use humanoid.MoveDirection (uses thumbstick or touch controls); add touch up/down
		if humanoid then
			dir = dir + humanoid.MoveDirection
		end
		if state.touchUp then dir = dir + Vector3.new(0,1,0) end
		if state.touchDown then dir = dir + Vector3.new(0,-1,0) end

		if dir.Magnitude > 0 then
			dir = dir.Unit
		end
		-- movement speed while flying influenced by WalkSpeed
		local speed = (humanoid and humanoid.WalkSpeed or DEFAULT_SPEED) * 1.2
		local move = dir * speed * dt
		-- safe translate
		pcall(function() character:TranslateBy(move) end)
	end)
end

local function stopFly()
	state.flying = false
	if flyConn then flyConn:Disconnect(); flyConn = nil end
end

-- Noclipping loop
local noclipConn
local function startNoclip()
	if state.noclip then return end
	state.noclip = true
	noclipConn = RS.Stepped:Connect(function()
		if not character then return end
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") then
				if part.Name ~= "HumanoidRootPart" then
					pcall(function() part.CanCollide = false end)
				end
			end
		end
	end)
end

local function stopNoclip()
	state.noclip = false
	if noclipConn then noclipConn:Disconnect(); noclipConn = nil end
	-- restore collisions (best effort)
	if character then
		for _, part in pairs(character:GetDescendants()) do
			if part:IsA("BasePart") then
				pcall(function() part.CanCollide = true end)
			end
		end
	end
end

-- Infinite jump
local jumpConn
local function enableInfJump()
	if state.infJump then return end
	state.infJump = true
	jumpConn = UIS.JumpRequest:Connect(function()
		if state.infJump and humanoid then
			pcall(function() humanoid:ChangeState(Enum.HumanoidStateType.Jumping) end)
		end
	end)
end
local function disableInfJump()
	state.infJump = false
	if jumpConn then jumpConn:Disconnect(); jumpConn = nil end
end

-- Buttons bindings
-- toggles: fly, noclip, infJump
flyToggle.button.MouseButton1Click:Connect(function()
	if not state.flying then
		flyToggle.button.BackgroundColor3 = Color3.fromRGB(0,170,90); flyToggle.button.Text = "ON"; startFly()
	else
		flyToggle.button.BackgroundColor3 = Color3.fromRGB(75,75,80); flyToggle.button.Text = "OFF"; stopFly()
	end
end)

noclipToggle.button.MouseButton1Click:Connect(function()
	if not state.noclip then
		noclipToggle.button.BackgroundColor3 = Color3.fromRGB(0,170,90); noclipToggle.button.Text = "ON"; startNoclip()
	else
		noclipToggle.button.BackgroundColor3 = Color3.fromRGB(75,75,80); noclipToggle.button.Text = "OFF"; stopNoclip()
	end
end)

infJumpToggle.button.MouseButton1Click:Connect(function()
	if not state.infJump then
		infJumpToggle.button.BackgroundColor3 = Color3.fromRGB(0,170,90); infJumpToggle.button.Text = "ON"; enableInfJump()
	else
		infJumpToggle.button.BackgroundColor3 = Color3.fromRGB(75,75,80); infJumpToggle.button.Text = "OFF"; disableInfJump()
	end
end)

-- Teleports
tpUpBtn.MouseButton1Click:Connect(function()
	if character and character:FindFirstChild("HumanoidRootPart") then
		pcall(function() character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame + Vector3.new(0,50,0) end)
	end
end)

tpMouseBtn.MouseButton1Click:Connect(function()
	-- Teleport to cursor/touch position on terrain or part under cursor
	local hit
	local mouse = player:GetMouse()
	-- On mobile, mouse.Hit still works with touch
	if mouse and mouse.Hit then
		hit = mouse.Hit
	end
	if hit and character and character:FindFirstChild("HumanoidRootPart") then
		pcall(function() character.HumanoidRootPart.CFrame = CFrame.new(hit.p + Vector3.new(0,3,0)) end)
	end
end)

tpNearestBtn.MouseButton1Click:Connect(function()
	local target = nearestPlayer()
	if target and target.Character and target.Character.PrimaryPart and character and character.PrimaryPart then
		pcall(function() character:SetPrimaryPartCFrame(target.Character.PrimaryPart.CFrame + Vector3.new(1,0,0)) end)
	end
end)

-- Remote tests
remoteFireBtn.MouseButton1Click:Connect(function()
	local remote = ReplicatedStorage:FindFirstChild("ExploitTestEvent")
	if remote and remote:IsA("RemoteEvent") then
		-- safe burst but not huge
		for i=1,20 do
			pcall(function() remote:FireServer("TestPayload", i) end)
		end
	end
end)

remoteBurstBtn.MouseButton1Click:Connect(function()
	local remote = ReplicatedStorage:FindFirstChild("ExploitTestEvent")
	if remote and remote:IsA("RemoteEvent") then
		for i=1,50 do
			pcall(function() remote:FireServer("Burst", i) end)
		end
	end
end)

-- Misc
sitBtn.MouseButton1Click:Connect(function()
	if humanoid then
		pcall(function()
			if humanoid.SeatPart then
				humanoid.Sit = false
			else
				humanoid.Sit = true
			end
		end)
	end
end)

regenBtn.MouseButton1Click:Connect(function()
	if humanoid then
		pcall(function() humanoid.Health = humanoid.MaxHealth end)
	end
end)

gravityBtn.MouseButton1Click:Connect(function()
	if not state.lowGravity then
		state.gravityPrev = workspace.Gravity
		workspace.Gravity = workspace.Gravity * 0.5
		gravityBtn.BackgroundColor3 = Color3.fromRGB(0,170,90)
		state.lowGravity = true
	else
		workspace.Gravity = state.gravityPrev or 196.2
		gravityBtn.BackgroundColor3 = Color3.fromRGB(36,36,40)
		state.lowGravity = false
	end
end)

fpsTeleportBtn.MouseButton1Click:Connect(function()
	if not character or not character.PrimaryPart then return end
	local forward = character.PrimaryPart.CFrame.LookVector * 10
	pcall(function() character:SetPrimaryPartCFrame(character.PrimaryPart.CFrame + forward) end)
end)

anticheckBtn.MouseButton1Click:Connect(function()
	print("-- LOCAL ANTI-CHEAT FLAGS --")
	print("flying", state.flying)
	print("noclip", state.noclip)
	print("infJump", state.infJump)
	print("lowGravity", state.lowGravity)
end)

-- Presets
preset1.MouseButton1Click:Connect(function()
	walkSlider.setFromX = walkSlider.setFromX or walkSlider.setFromX
	-- set slider visually
	local p = (100 - 0) / (MAX_SPEED - 0)
	walkSlider.setFromX(walkSlider.container.AbsolutePosition.X + p * walkSlider.container.AbsoluteSize.X) -- best effort
	-- simpler: just set labels
	walkSlider.valLabel.Text = "100"
	jumpSlider.valLabel.Text = "100"
end)

preset2.MouseButton1Click:Connect(function()
	walkSlider.valLabel.Text = "50"
	jumpSlider.valLabel.Text = "200"
end)

resetAll.MouseButton1Click:Connect(function()
	-- stop toggles
	if state.flying then stopFly() end
	if state.noclip then stopNoclip() end
	if state.infJump then disableInfJump() end
	if state.lowGravity then workspace.Gravity = state.gravityPrev; state.lowGravity = false end

	-- reset humanoid props
	pcall(function()
		if humanoid then
			humanoid.WalkSpeed = DEFAULT_SPEED
			humanoid.JumpPower = DEFAULT_JUMP
			humanoid.Health = humanoid.MaxHealth
		end
	end)

	-- reset UI text for toggles
	flyToggle.button.BackgroundColor3 = Color3.fromRGB(75,75,80); flyToggle.button.Text = "OFF"
	noclipToggle.button.BackgroundColor3 = Color3.fromRGB(75,75,80); noclipToggle.button.Text = "OFF"
	infJumpToggle.button.BackgroundColor3 = Color3.fromRGB(75,75,80); infJumpToggle.button.Text = "OFF"
	gravityBtn.BackgroundColor3 = Color3.fromRGB(36,36,40)
end)

-- Close / Toggle UI
closeBtn.MouseButton1Click:Connect(function()
	frame.Visible = false
end)
toggleBtn.MouseButton1Click:Connect(function()
	frame.Visible = not frame.Visible
end)

-- Make the title bar draggable for touch + mouse (custom, robust)
do
	local dragging, dragStart, startPos
	titleBar.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = frame.Position
			local conn
			conn = input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
					conn:Disconnect()
				end
			end)
		end
	end)
	titleBar.InputChanged:Connect(function(input)
		if not dragging then return end
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			local delta = input.Position - dragStart
			frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
		end
	end)
end

-- Ensure sliders initialize visually once UI measured
local initConn
initConn = RS.Heartbeat:Connect(function()
	if walkSlider and walkSlider.container and walkSlider.container.AbsoluteSize.X > 0 then
		-- initialize slider visuals to defaults (safe)
		local defaultW = DEFAULT_SPEED
		local defaultJ = DEFAULT_JUMP
		local pW = math.clamp((defaultW - 0) / (MAX_SPEED - 0), 0, 1)
		local pJ = math.clamp((defaultJ - 0) / (MAX_JUMP - 0), 0, 1)
		-- set fill/knob by calling internal setFromX via absolute positions
		-- best-effort: set valLabel directly
		walkSlider.valLabel.Text = tostring(defaultW)
		jumpSlider.valLabel.Text = tostring(defaultJ)
		initConn:Disconnect()
	end
end)

-- Safety note printed to Output
print("[sx.exploits.p1] Ready.")
