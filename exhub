-- exhub (loadstring-friendly, client+server, open-to-all by default)
-- Usage:
--  - Run on the server (Script / Command Bar) once to create the RemoteEvent and server-side handlers.
--  - Run on clients (LocalScript or via loadstring on the client) to spawn the UI.
--  - Or simply run loadstring(<this file text>)() in supported environments.
--
-- Configuration (edit as needed):
local CONFIG = {
    RunForAll = true,              -- true: everyone can use the menu. false: only AdminUserIds
    AdminUserIds = { 0 },          -- list of allowed admin UserIds when RunForAll = false
    ToggleKey = Enum.KeyCode.RightControl, -- key to toggle the UI on client (desktop)
    RemoteEventName = "ModMenuAction",     -- RemoteEvent name in ReplicatedStorage
    AllowClientFallback = true,    -- if RemoteEvent missing on client, do limited local-only actions
}

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local StarterGui = game:GetService("StarterGui")
local ServerStorage = game:GetService("ServerStorage")
local Workspace = game:GetService("Workspace")

local isServer = RunService:IsServer()
local isClient = RunService:IsClient()

-- Utility: shallow contains check
local function tcontains(t, v)
    if not t then return false end
    for _,x in ipairs(t) do if x == v then return true end end
    return false
end

-- SERVER: create RemoteEvent and handler
if isServer then
    -- ensure RemoteEvent exists
    local event = ReplicatedStorage:FindFirstChild(CONFIG.RemoteEventName)
    if event and not event:IsA("RemoteEvent") then
        event:Destroy()
        event = nil
    end
    if not event then
        event = Instance.new("RemoteEvent")
        event.Name = CONFIG.RemoteEventName
        event.Parent = ReplicatedStorage
    end

    -- Admin check (server-side authoritative)
    local function isAdminServer(player)
        if CONFIG.RunForAll then return true end
        if not player then return false end
        return tcontains(CONFIG.AdminUserIds, player.UserId)
    end

    -- helper to resolve player by name or instance
    local function safeFindPlayer(identifier)
        if typeof(identifier) == "Instance" and identifier:IsA("Player") then
            return identifier
        elseif typeof(identifier) == "string" then
            for _, p in ipairs(Players:GetPlayers()) do
                if p.Name:lower() == tostring(identifier):lower() then
                    return p
                end
            end
        end
        return nil
    end

    local function handleAction(player, payload)
        if not isAdminServer(player) then
            warn(player.Name .. " attempted to use mod menu but is not admin.")
            return
        end
        if type(payload) ~= "table" or type(payload.action) ~= "string" then return end

        local action = payload.action
        local targetIdentifier = payload.target
        local value = payload.value

        if action == "teleport" then
            local targetPlayer = safeFindPlayer(targetIdentifier)
            if targetPlayer and targetPlayer.Character and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetHRP and hrp then
                    hrp.CFrame = targetHRP.CFrame + Vector3.new(2,0,0)
                end
            end

        elseif action == "setWalkSpeed" then
            local targetPlayer = safeFindPlayer(targetIdentifier) or player
            if targetPlayer and targetPlayer.Character then
                local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid and type(value) == "number" then
                    humanoid.WalkSpeed = math.clamp(value, 0, 200)
                end
            end

        elseif action == "setJumpPower" then
            local targetPlayer = safeFindPlayer(targetIdentifier) or player
            if targetPlayer and targetPlayer.Character then
                local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid and type(value) == "number" then
                    humanoid.JumpPower = math.clamp(value, 0, 300)
                end
            end

        elseif action == "kick" then
            local targetPlayer = safeFindPlayer(targetIdentifier)
            if targetPlayer then
                targetPlayer:Kick(value or "Kicked by admin")
            end

        elseif action == "giveTool" then
            local toolName = value
            local targetPlayer = safeFindPlayer(targetIdentifier) or player
            if type(toolName) == "string" and targetPlayer then
                local tool = ServerStorage:FindFirstChild(toolName)
                if tool and tool:IsA("Tool") then
                    local clone = tool:Clone()
                    clone.Parent = targetPlayer:FindFirstChild("Backpack") or targetPlayer
                end
            end

        elseif action == "setGravity" then
            if type(value) == "number" then
                Workspace.Gravity = math.clamp(value, 0, 500)
            end

        elseif action == "heal" then
            local targetPlayer = safeFindPlayer(targetIdentifier) or player
            if targetPlayer and targetPlayer.Character then
                local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid.Health = humanoid.MaxHealth
                end
            end

        else
            warn("Unknown mod menu action: "..tostring(action))
        end
    end

    -- Connect event
    event.OnServerEvent:Connect(function(player, payload)
        local ok, err = pcall(handleAction, player, payload)
        if not ok then
            warn("Error handling mod menu action from " .. (player and player.Name or "unknown") .. ": " .. tostring(err))
        end
    end)

    -- Optional: send a message to server log
    print("[exhub] Mod Menu server handler installed. RemoteEvent:", event:GetFullName())
    print("[exhub] RunForAll =", tostring(CONFIG.RunForAll))
    return
end

-- CLIENT: create UI and use RemoteEvent if available
if isClient then
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")
    local player = Players.LocalPlayer

    -- Try to find RemoteEvent
    local event = ReplicatedStorage:FindFirstChild(CONFIG.RemoteEventName)
    if event and not event:IsA("RemoteEvent") then event = nil end

    local function isAdminClient()
        if CONFIG.RunForAll then return true end
        return tcontains(CONFIG.AdminUserIds, player.UserId)
    end

    local function canUseRemote()
        return event ~= nil
    end

    -- Fallback local action handler (limited and client-side only)
    local function localHandleAction(payload)
        if not isAdminClient() then
            warn("local: not admin")
            return
        end
        if type(payload) ~= "table" or type(payload.action) ~= "string" then return end
        local action = payload.action
        local targetIdentifier = payload.target
        local value = payload.value

        local function findLocalPlayer(name)
            if not name then return player end
            if typeof(name) == "Instance" and name:IsA("Player") then return name end
            for _,p in ipairs(Players:GetPlayers()) do
                if p.Name:lower() == tostring(name):lower() then return p end
            end
            return nil
        end

        local targetPlayer = findLocalPlayer(targetIdentifier) or player

        if action == "teleport" then
            if targetPlayer and targetPlayer.Character and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                local targetHRP = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
                if targetHRP and hrp then
                    hrp.CFrame = targetHRP.CFrame + Vector3.new(2,0,0)
                end
            end
        elseif action == "setWalkSpeed" then
            if targetPlayer and targetPlayer.Character then
                local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid and type(value) == "number" then
                    humanoid.WalkSpeed = math.clamp(value, 0, 200)
                end
            end
        elseif action == "setJumpPower" then
            if targetPlayer and targetPlayer.Character then
                local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid and type(value) == "number" then
                    humanoid.JumpPower = math.clamp(value, 0, 300)
                end
            end
        elseif action == "heal" then
            if targetPlayer and targetPlayer.Character then
                local humanoid = targetPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid.Health = humanoid.MaxHealth
                end
            end
        else
            warn("local: Unknown action:", action)
        end
    end

    -- sendAction tries RemoteEvent, falls back to local if allowed
    local function sendAction(payload)
        if canUseRemote() then
            pcall(function() event:FireServer(payload) end)
        else
            if CONFIG.AllowClientFallback then
                pcall(function() localHandleAction(payload) end)
            else
                warn("[exhub] RemoteEvent not available and client fallback is disabled.")
            end
        end
    end

    -- UI builder helpers (kept compact but similar to original)
    local function new(class, props)
        local obj = Instance.new(class)
        if props then
            for k,v in pairs(props) do
                if k ~= "Parent" then pcall(function() obj[k] = v end) end
            end
            if props.Parent then obj.Parent = props.Parent end
        end
        return obj
    end

    -- create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ModMenuGui"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.Parent = player:WaitForChild("PlayerGui")

    -- Main window: use scale so it works on mobile; but constrain max pixel size for desktop
    local main = new("Frame", {
        Name = "MainWindow",
        Parent = screenGui,
        Size = UDim2.new(0.92, 0, 0.78, 0), -- responsive by default
        Position = UDim2.new(0.5, 0, 0.08, 0),
        BackgroundColor3 = Color3.fromRGB(24,24,24),
        BorderSizePixel = 0,
    })
    main.AnchorPoint = Vector2.new(0.5,0)
    new("UICorner", {Parent=main, CornerRadius=UDim.new(0,8)})
    -- limit max size on large displays
    local sizeConstraint = new("UISizeConstraint", { Parent = main })
    sizeConstraint.MaxSize = Vector2.new(820, 760)

    -- Header (drag handle)
    local header = new("Frame", { Parent = main, Size = UDim2.new(1,0,0,40), BackgroundTransparency = 1 })
    local title = new("TextLabel", {
        Parent = header, Text = "Mod Menu", TextColor3 = Color3.fromRGB(220,220,220),
        Font = Enum.Font.GothamBold, TextSize = 18, BackgroundTransparency = 1,
        Position = UDim2.new(0,12,0,6), Size = UDim2.new(0.6,0,1,0),
    })
    local closeBtn = new("TextButton", {
        Parent = header, Text = "X", TextColor3 = Color3.fromRGB(200,200,200),
        BackgroundTransparency = 1, Position = UDim2.new(1,-44,0,6), Size = UDim2.new(0,36,0,28),
        Font = Enum.Font.Gotham, TextSize = 18,
    })
    closeBtn.MouseButton1Click:Connect(function() main.Visible = false end)

    -- Dragging (supports mouse + touch)
    local dragging, dragInput, dragStart, startPos = false, nil, nil, nil
    header.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = main.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    header.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging and dragStart and startPos then
            local delta = input.Position - dragStart
            main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)

    -- Body layout: left player list and right controls (right side is scrollable on small screens)
    local left = new("Frame", { Parent = main, Size = UDim2.new(0.36, -12, 1, -64), Position = UDim2.new(0,8,0,48), BackgroundColor3 = Color3.fromRGB(18,18,18), BorderSizePixel = 0 })
    new("UICorner", {Parent=left, CornerRadius=UDim.new(0,6)})
    local leftScroll = new("ScrollingFrame", {
        Parent = left, Size = UDim2.new(1,-6,1,-6), Position = UDim2.new(0,3,0,3),
        BackgroundTransparency = 1, CanvasSize = UDim2.new(0,0,0,0), ScrollBarThickness = 8,
        VerticalScrollBarInset = Enum.ScrollBarInset.Always,
    })
    local listLayout = new("UIListLayout", {Parent = leftScroll, Padding = UDim.new(0,6)})
    listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        leftScroll.CanvasSize = UDim2.new(0,0,0,listLayout.AbsoluteContentSize.Y + 12)
    end)

    -- Right side uses a ScrollingFrame so controls are always reachable on mobile
    local right = new("Frame", { Parent = main, Size = UDim2.new(0.62, -12, 1, -64), Position = UDim2.new(0.38, 8, 0, 48), BackgroundTransparency = 1 })
    local rightScroll = new("ScrollingFrame", { Parent = right, Size = UDim2.new(1,0,1,0), BackgroundTransparency = 1, CanvasSize = UDim2.new(0,0,0,0), ScrollBarThickness = 8, VerticalScrollBarInset = Enum.ScrollBarInset.Always })
    local rightBg = new("Frame", { Parent = rightScroll, Size = UDim2.new(1,0,0,200), BackgroundColor3 = Color3.fromRGB(14,14,14), BorderSizePixel = 0 })
    new("UICorner", {Parent=rightBg, CornerRadius=UDim.new(0,6)})

    local function makeLabel(parent, text, posY)
        return new("TextLabel", {
            Parent = parent, Text = text, TextColor3 = Color3.fromRGB(200,200,200),
            BackgroundTransparency = 1, Size = UDim2.new(1,-12,0,20), Position = UDim2.new(0,8,0,posY),
            Font = Enum.Font.Gotham, TextSize = 14, TextXAlignment = Enum.TextXAlignment.Left,
        })
    end

    local function makeSlider(parent, name, min, max, default, posY)
        makeLabel(parent, name, posY)
        local frame = new("Frame", { Parent = parent, Size = UDim2.new(1,-16,0,40), Position = UDim2.new(0,8,0,posY+22), BackgroundTransparency = 1 })
        local barBg = new("Frame", {Parent = frame, Size = UDim2.new(1,0,0,10), Position = UDim2.new(0,0,0,12), BackgroundColor3 = Color3.fromRGB(50,50,50)})
        new("UICorner", {Parent=barBg, CornerRadius=UDim.new(0,5)})
        local fill = new("Frame", {Parent = barBg, Size = UDim2.new((default-min)/(max-min),0,1,0), BackgroundColor3 = Color3.fromRGB(30,120,220)})
        new("UICorner", {Parent=fill, CornerRadius=UDim.new(0,5)})
        local valueLabel = new("TextLabel", { Parent = frame, Text = tostring(default), BackgroundTransparency = 1, Size = UDim2.new(0,64,1,0), Position = UDim2.new(1,-64,0,0), TextColor3 = Color3.fromRGB(220,220,220), Font = Enum.Font.Gotham, TextSize = 14 })

        local draggingBar = false
        barBg.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then draggingBar = true end
        end)
        barBg.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then draggingBar = false end end)
        UserInputService.InputChanged:Connect(function(input)
            if draggingBar and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                local rel = math.clamp((input.Position.X - barBg.AbsolutePosition.X) / barBg.AbsoluteSize.X, 0, 1)
                fill.Size = UDim2.new(rel,0,1,0)
                local value = math.floor((min + (max-min)*rel) * 100) / 100
                valueLabel.Text = tostring(value)
            end
        end)
        return { frame = frame, set = function(v)
            local rel = (v-min)/(max-min)
            fill:TweenSize(UDim2.new(math.clamp(rel,0,1),0,1,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.15, true)
            valueLabel.Text = tostring(v)
        end, get = function() return tonumber(valueLabel.Text) or default end }
    end

    local function makeActionButton(name, posY, callback)
        local btn = new("TextButton", { Parent = rightBg, Text = name, BackgroundColor3 = Color3.fromRGB(35,120,230), TextColor3 = Color3.fromRGB(255,255,255), Position = UDim2.new(0,8,0,posY), Size = UDim2.new(0.45,-12,0,36), Font = Enum.Font.Gotham, TextSize = 16 })
        new("UICorner", {Parent=btn, CornerRadius=UDim.new(0,6)})
        btn.MouseButton1Click:Connect(callback)
        return btn
    end

    -- build right-side controls
    local y = 8
    makeLabel(rightBg, "Target Player (tap a name on the left)", y)
    y = y + 28
    local walkSlider = makeSlider(rightBg, "WalkSpeed", 8, 200, 16, y)
    y = y + 64
    local jumpSlider = makeSlider(rightBg, "JumpPower", 25, 300, 50, y)
    y = y + 64
    local gravitySlider = makeSlider(rightBg, "Gravity", 0, 500, 196, y)
    y = y + 64

    local actionY = y
    local teleportBtn = makeActionButton("Teleport To", actionY, function()
        local targetName = rightBg:GetAttribute("selected")
        if not targetName then return end
        sendAction({ action = "teleport", target = targetName })
    end)
    local kickBtn = makeActionButton("Kick", actionY + 44, function()
        local targetName = rightBg:GetAttribute("selected")
        if not targetName then return end
        sendAction({ action = "kick", target = targetName, value = "Kicked by admin" })
    end)
    local giveBtn = makeActionButton("Give TestTool", actionY + 88, function()
        local targetName = rightBg:GetAttribute("selected")
        if not targetName then return end
        sendAction({ action = "giveTool", target = targetName, value = "TestTool" })
    end)
    local healBtn = makeActionButton("Heal", actionY + 132, function()
        local target = rightBg:GetAttribute("selected")
        sendAction({ action = "heal", target = target })
    end)

    -- position action buttons nicer on small widths (two columns if space)
    teleportBtn.Position = UDim2.new(0,8,0,actionY)
    kickBtn.Position = UDim2.new(0.5, -6, 0, actionY)
    giveBtn.Position = UDim2.new(0,8,0,actionY + 44)
    healBtn.Position = UDim2.new(0.5, -6, 0,actionY + 44)

    local function sendWalk(v)
        local target = rightBg:GetAttribute("selected")
        sendAction({ action = "setWalkSpeed", target = target, value = v })
    end
    local function sendJump(v)
        local target = rightBg:GetAttribute("selected")
        sendAction({ action = "setJumpPower", target = target, value = v })
    end
    local function sendGravity(v)
        sendAction({ action = "setGravity", value = v })
    end

    -- throttle loop for sliders
    spawn(function()
        local lastW, lastJ, lastG
        while true do
            wait(0.4)
            local w = walkSlider.get()
            local j = jumpSlider.get()
            local g = gravitySlider.get()
            if w and w ~= lastW then lastW = w; sendWalk(w) end
            if j and j ~= lastJ then lastJ = j; sendJump(j) end
            if g and g ~= lastG then lastG = g; sendGravity(g) end
        end
    end)

    -- player list population
    local function addPlayerToList(p)
        local btn = new("TextButton", {
            Parent = leftScroll, Text = p.Name, Size = UDim2.new(1,-6,0,36),
            BackgroundColor3 = Color3.fromRGB(25,25,25), TextColor3 = Color3.fromRGB(220,220,220),
            Font = Enum.Font.Gotham, TextSize = 16,
        })
        new("UICorner", {Parent=btn, CornerRadius=UDim.new(0,6)})
        btn.MouseButton1Click:Connect(function()
            for _,child in ipairs(leftScroll:GetChildren()) do
                if child:IsA("TextButton") then child.BackgroundColor3 = Color3.fromRGB(25,25,25) end
            end
            btn.BackgroundColor3 = Color3.fromRGB(40,80,140)
            rightBg:SetAttribute("selected", p.Name)
        end)
    end

    for _, p in ipairs(Players:GetPlayers()) do addPlayerToList(p) end
    Players.PlayerAdded:Connect(function(p) addPlayerToList(p) end)
    Players.PlayerRemoving:Connect(function(pl)
        for _, child in ipairs(leftScroll:GetChildren()) do
            if child:IsA("TextButton") and child.Text == pl.Name then child:Destroy() end
        end
        if rightBg:GetAttribute("selected") == pl.Name then rightBg:SetAttribute("selected", nil) end
    end)

    -- Update rightBg size and rightScroll canvas so content is scrollable
    rightBg.Size = UDim2.new(1,0,0, y + 20)
    rightScroll.CanvasSize = UDim2.new(0,0,0, y + 30)

    -- mobile-friendly toggle button (visible when touch enabled)
    if UserInputService.TouchEnabled then
        local mobileToggle = new("TextButton", {
            Parent = screenGui, Text = "≡", TextColor3 = Color3.fromRGB(255,255,255),
            BackgroundColor3 = Color3.fromRGB(30,30,30), Size = UDim2.new(0,56,0,56), Position = UDim2.new(0.03,0,0.88,0),
            Font = Enum.Font.GothamBold, TextSize = 28, AutoButtonColor = true,
        })
        new("UICorner", {Parent=mobileToggle, CornerRadius=UDim.new(0,10)})
        mobileToggle.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
                if not isAdminClient() then
                    warn("mobile: not admin")
                    return
                end
                main.Visible = not main.Visible
            end
        end)
    end

    -- desktop toggle (keyboard)
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == CONFIG.ToggleKey then
            main.Visible = not main.Visible
        end
    end)

    -- default slider values
    walkSlider.set(16)
    jumpSlider.set(50)
    gravitySlider.set(196)

    -- initial visibility
    main.Visible = isAdminClient()

    -- simple note in output
    if canUseRemote() then
        print("[exhub] Connected to server RemoteEvent:", event:GetFullName())
    else
        print("[exhub] RemoteEvent not found. Client fallback is", tostring(CONFIG.AllowClientFallback) .. ".")
    end
end
