-- exhub (improved)
-- Single-file loadstring-friendly mod menu (self-only)
-- Usage:
--  - Run on the server (Script / Command Bar) once to create the RemoteEvent and server-side handlers.
--  - Run on clients (LocalScript or via loadstring on the client) to spawn the UI.
--  - Or simply run loadstring(<this file text>)() in supported environments.
--
-- Changes in this version:
--  - Draggable window (desktop & touch) with snap/center controls.
--  - Edge "X" unload button to cleanly remove the UI and stop all client behaviors.
--  - Fixed slider bug and many connection/disconnect issues.
--  - Improved connection tracking and safe cleanup on unload.
--  - Better input handling, robust fallbacks when RemoteEvent missing.
--  - Minor quality-of-life features: minimize, center, lock position, version label.
--
-- Security model:
--  - Server handlers only operate on the calling player (self-only) and require admin check if RunForAll=false.
--  - Client can optionally fall back to local-only operations when the RemoteEvent is missing and AllowClientFallback=true.
--

local CONFIG = {
    RunForAll = true,              -- true: everyone can use the menu. false: only AdminUserIds
    AdminUserIds = { 0 },          -- list of allowed admin UserIds when RunForAll = false
    ToggleKey = Enum.KeyCode.RightControl, -- key to toggle the UI on client (desktop)
    RemoteEventName = "ModMenuAction",     -- RemoteEvent name in ReplicatedStorage
    AllowClientFallback = true,    -- if RemoteEvent missing on client, do limited local-only actions
    FillScreenPercent = 0.88,      -- size multiplier for screen gui main window
    Version = "v2.0.0",
}

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local StarterGui = game:GetService("StarterGui")
local ServerStorage = game:GetService("ServerStorage")
local Workspace = game:GetService("Workspace")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")

local isServer = RunService:IsServer()
local isClient = RunService:IsClient()

-- Utility: shallow contains check
local function tcontains(t, v)
    if not t then return false end
    for _,x in ipairs(t) do if x == v then return true end end
    return false
end

-- helper to resolve player by name or instance (server-side only)
local function safeFindPlayer(identifier)
    if typeof(identifier) == "Instance" and identifier:IsA("Player") then
        return identifier
    elseif typeof(identifier) == "string" then
        for _, p in ipairs(Players:GetPlayers()) do
            if p.Name:lower() == tostring(identifier):lower() then
                return p
            end
        end
    end
    return nil
end

-- SERVER: create RemoteEvent and handler (server-authoritative, only acts on calling player)
if isServer then
    -- ensure RemoteEvent exists and is a RemoteEvent
    local event = ReplicatedStorage:FindFirstChild(CONFIG.RemoteEventName)
    if event and not event:IsA("RemoteEvent") then
        event:Destroy()
        event = nil
    end
    if not event then
        event = Instance.new("RemoteEvent")
        event.Name = CONFIG.RemoteEventName
        event.Parent = ReplicatedStorage
    end

    -- Admin check (server-side authoritative)
    local function isAdminServer(player)
        if CONFIG.RunForAll then return true end
        if not player then return false end
        return tcontains(CONFIG.AdminUserIds, player.UserId)
    end

    local function getCharacterParts(char)
        local parts = {}
        if not char then return parts end
        for _, d in ipairs(char:GetDescendants()) do
            if d:IsA("BasePart") then table.insert(parts, d) end
        end
        return parts
    end

    local function handleAction(player, payload)
        -- payload must be a table with .action and may have .value or .position (Vector3)
        if not isAdminServer(player) then
            warn(player and player.Name or "unknown", "attempted to use mod menu but is not admin.")
            return
        end
        if type(payload) ~= "table" or type(payload.action) ~= "string" then return end

        local action = payload.action
        local value = payload.value
        local position = payload.position

        -- Always operate on the calling player (self-only)
        local targetPlayer = player
        if not targetPlayer then return end

        -- convenience: get character/humanoid/hrp
        local char = targetPlayer.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")

        if action == "teleportToPosition" then
            if hrp and typeof(position) == "Vector3" then
                hrp.CFrame = CFrame.new(position) + Vector3.new(0,2,0)
            end

        elseif action == "teleportToPlayer" then
            -- teleport self to another player's HRP
            local other = safeFindPlayer(value)
            if other and other.Character and other.Character:FindFirstChild("HumanoidRootPart") and hrp then
                hrp.CFrame = other.Character.HumanoidRootPart.CFrame + Vector3.new(0,2,0)
            end

        elseif action == "teleportToSpawn" then
            -- teleport to first SpawnLocation / respawn location found
            local found
            for _, obj in ipairs(Workspace:GetDescendants()) do
                if obj:IsA("SpawnLocation") and obj.Position then
                    found = obj
                    break
                end
            end
            if hrp and found then
                hrp.CFrame = CFrame.new(found.Position) + Vector3.new(0,2,0)
            end

        elseif action == "resetCharacter" then
            if targetPlayer and targetPlayer.Character then
                pcall(function() targetPlayer:LoadCharacter() end)
            end

        elseif action == "setWalkSpeed" then
            if humanoid and type(value) == "number" then
                humanoid.WalkSpeed = math.clamp(value, 0, 1000)
            end

        elseif action == "setJumpPower" then
            if humanoid and type(value) == "number" then
                pcall(function() humanoid.JumpPower = math.clamp(value, 0, 1000) end)
            end

        elseif action == "setGravity" then
            if type(value) == "number" then
                Workspace.Gravity = math.clamp(value, 0, 1000)
            end

        elseif action == "heal" then
            if humanoid then
                humanoid.Health = humanoid.MaxHealth
            end

        elseif action == "giveTool" then
            -- Only give to self
            local toolName = value
            if type(toolName) == "string" and targetPlayer then
                local tool = ServerStorage:FindFirstChild(toolName)
                if tool and tool:IsA("Tool") then
                    local clone = tool:Clone()
                    local backpack = targetPlayer:FindFirstChild("Backpack")
                    if backpack then
                        clone.Parent = backpack
                    else
                        clone.Parent = targetPlayer
                    end
                end
            end

        elseif action == "setMaxHealth" then
            if humanoid and type(value) == "number" then
                humanoid.MaxHealth = math.max(1, value)
                humanoid.Health = humanoid.MaxHealth
            end

        elseif action == "setTransparency" then
            -- set character transparency (value 0..1)
            if char and type(value) == "number" then
                for _, part in ipairs(getCharacterParts(char)) do
                    if part and part:IsA("BasePart") then
                        part.Transparency = math.clamp(value, 0, 1)
                    end
                end
            end

        elseif action == "setAnchored" then
            -- value = boolean
            if char and type(value) == "boolean" then
                for _, part in ipairs(getCharacterParts(char)) do
                    if part and part:IsA("BasePart") then
                        part.Anchored = value
                    end
                end
            end

        elseif action == "removeTools" then
            local backpack = targetPlayer:FindFirstChild("Backpack")
            if backpack then
                for _, item in ipairs(backpack:GetChildren()) do
                    if item:IsA("Tool") then item:Destroy() end
                end
            end
            -- also remove equipped tool
            if char then
                for _, item in ipairs(char:GetChildren()) do
                    if item:IsA("Tool") then item:Destroy() end
                end
            end

        else
            warn("Unknown mod menu action (server): "..tostring(action))
        end
    end

    event.OnServerEvent:Connect(function(player, payload)
        local ok, err = pcall(handleAction, player, payload)
        if not ok then
            warn("Error handling mod menu action from " .. (player and player.Name or "unknown") .. ": " .. tostring(err))
        end
    end)

    print("[exhub] Mod Menu server handler installed. RemoteEvent:", event:GetFullName())
    print("[exhub] RunForAll =", tostring(CONFIG.RunForAll))
    return
end

-- CLIENT: create UI and local behavior (self-only)
if isClient then
    local player = Players.LocalPlayer
    if not player then return end

    -- Try to find RemoteEvent (no WaitForChild to allow fallback)
    local event = ReplicatedStorage:FindFirstChild(CONFIG.RemoteEventName)
    if event and not event:IsA("RemoteEvent") then event = nil end

    local function isAdminClient()
        if CONFIG.RunForAll then return true end
        return tcontains(CONFIG.AdminUserIds, player.UserId)
    end

    local function canUseRemote()
        return event ~= nil
    end

    -- connection tracking for cleanup
    local trackedConns = {}
    local function trackConn(conn)
        if conn then table.insert(trackedConns, conn) end
        return conn
    end
    local function safeDisconnect(conn)
        if not conn then return end
        local ok, _ = pcall(function() conn:Disconnect() end)
        return ok
    end
    local function disconnectAll()
        for _, c in ipairs(trackedConns) do
            pcall(function() c:Disconnect() end)
        end
        trackedConns = {}
    end

    -- internal state
    local loaded = true

    -- Fallback local action handler (limited and client-side only)
    local function localHandleAction(payload)
        if not isAdminClient() then
            warn("local: not admin")
            return
        end
        if type(payload) ~= "table" or type(payload.action) ~= "string" then return end
        local action = payload.action
        local value = payload.value
        local position = payload.position

        local char = player.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        local hrp = char and char:FindFirstChild("HumanoidRootPart")

        if action == "teleportToPosition" then
            if hrp and typeof(position) == "Vector3" then hrp.CFrame = CFrame.new(position) + Vector3.new(0,2,0) end

        elseif action == "teleportToPlayer" then
            local other = safeFindPlayer(value)
            if other and other.Character and other.Character:FindFirstChild("HumanoidRootPart") and hrp then
                hrp.CFrame = other.Character.HumanoidRootPart.CFrame + Vector3.new(0,2,0)
            end

        elseif action == "teleportToSpawn" then
            local found
            for _, obj in ipairs(Workspace:GetDescendants()) do
                if obj:IsA("SpawnLocation") and obj.Position then
                    found = obj
                    break
                end
            end
            if hrp and found then hrp.CFrame = CFrame.new(found.Position) + Vector3.new(0,2,0) end

        elseif action == "resetCharacter" then
            pcall(function() player:LoadCharacter() end)

        elseif action == "setWalkSpeed" then
            if humanoid and type(value) == "number" then humanoid.WalkSpeed = math.clamp(value, 0, 1000) end

        elseif action == "setJumpPower" then
            if humanoid and type(value) == "number" then pcall(function() humanoid.JumpPower = math.clamp(value, 0, 1000) end) end

        elseif action == "setGravity" then
            if type(value) == "number" then Workspace.Gravity = math.clamp(value, 0, 1000) end

        elseif action == "heal" then
            if humanoid then humanoid.Health = humanoid.MaxHealth end

        elseif action == "giveTool" then
            local toolName = value
            if type(toolName) == "string" then
                local tool = ServerStorage:FindFirstChild(toolName)
                if tool and tool:IsA("Tool") then
                    local clone = tool:Clone()
                    local backpack = player:FindFirstChild("Backpack")
                    if backpack then clone.Parent = backpack else clone.Parent = player end
                end
            end

        elseif action == "setMaxHealth" then
            if humanoid and type(value) == "number" then humanoid.MaxHealth = math.max(1, value); humanoid.Health = humanoid.MaxHealth end

        elseif action == "setTransparency" then
            if char and type(value) == "number" then
                for _, d in ipairs(char:GetDescendants()) do
                    if d:IsA("BasePart") then d.Transparency = math.clamp(value,0,1) end
                end
            end

        elseif action == "setAnchored" then
            if char and type(value) == "boolean" then
                for _, d in ipairs(char:GetDescendants()) do
                    if d:IsA("BasePart") then d.Anchored = value end
                end
            end

        elseif action == "removeTools" then
            local backpack = player:FindFirstChild("Backpack")
            if backpack then for _, it in ipairs(backpack:GetChildren()) do if it:IsA("Tool") then it:Destroy() end end end
            if char then for _, it in ipairs(char:GetChildren()) do if it:IsA("Tool") then it:Destroy() end end end

        else
            warn("local: Unknown action:", action)
        end
    end

    -- sendAction tries RemoteEvent, falls back to local if allowed
    local function sendAction(payload)
        if canUseRemote() then
            pcall(function() event:FireServer(payload) end)
        else
            if CONFIG.AllowClientFallback then
                pcall(function() localHandleAction(payload) end)
            else
                warn("[exhub] RemoteEvent not available and client fallback is disabled.")
            end
        end
    end

    -- UI builder helpers
    local function new(class, props)
        local obj = Instance.new(class)
        if props then
            for k,v in pairs(props) do
                if k ~= "Parent" then
                    pcall(function() obj[k] = v end)
                end
            end
            if props.Parent then obj.Parent = props.Parent end
        end
        return obj
    end

    -- create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ModMenuGui"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.Parent = player:WaitForChild("PlayerGui")

    -- Main window (we use offset positioning to make dragging straightforward)
    local main = new("Frame", {
        Name = "MainWindow",
        Parent = screenGui,
        Size = UDim2.new(CONFIG.FillScreenPercent, 0, 0.78, 0),
        Position = UDim2.new(0.08, 0, 0.08, 0), -- temporary; we'll center after size known
        BackgroundColor3 = Color3.fromRGB(18, 22, 30),
        BorderSizePixel = 0,
    })
    main.AnchorPoint = Vector2.new(0,0)
    new("UICorner", {Parent=main, CornerRadius=UDim.new(0,10)})
    local sizeConstraint = new("UISizeConstraint", { Parent = main })
    sizeConstraint.MaxSize = Vector2.new(1200, 900)

    -- subtle shadow
    local shadow = new("Frame", {Parent = main, Size = UDim2.new(1,6,1,6), Position = UDim2.new(0,-3,0,-3), BackgroundTransparency = 0.9})
    shadow.ZIndex = 0

    -- Header
    local header = new("Frame", { Parent = main, Size = UDim2.new(1,0,0,52), BackgroundTransparency = 1 })
    local title = new("TextLabel", {
        Parent = header, Text = "ExHub - Self Menu", TextColor3 = Color3.fromRGB(240,240,240),
        Font = Enum.Font.GothamBold, TextSize = 18, BackgroundTransparency = 1,
        Position = UDim2.new(0,16,0,6), Size = UDim2.new(0.6,0,1,0),
    })
    local subtitle = new("TextLabel", {
        Parent = header, Text = "Organized â€¢ Safe â€¢ Self-only â€¢ " .. CONFIG.Version, TextColor3 = Color3.fromRGB(170,170,170),
        Font = Enum.Font.Gotham, TextSize = 11, BackgroundTransparency = 1,
        Position = UDim2.new(0,16,0,28), Size = UDim2.new(0.6,0,1,0),
    })

    -- close (minimize) button inside header
    local closeBtn = new("TextButton", {
        Parent = header, Text = "â€”", TextColor3 = Color3.fromRGB(200,200,200),
        BackgroundTransparency = 1, Position = UDim2.new(1,-110,0,8), Size = UDim2.new(0,48,0,36),
        Font = Enum.Font.GothamBold, TextSize = 20,
    })
    closeBtn.MouseButton1Click:Connect(function() main.Visible = false end)

    -- center and lock buttons
    local centerBtn = new("TextButton", {
        Parent = header, Text = "â—Ž", TextColor3 = Color3.fromRGB(200,200,200),
        BackgroundTransparency = 1, Position = UDim2.new(1,-160,0,8), Size = UDim2.new(0,48,0,36),
        Font = Enum.Font.GothamBold, TextSize = 18,
    })
    centerBtn.MouseButton1Click:Connect(function()
        -- center the window smoothly
        local viewport = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1280,720)
        local newX = math.max(10, math.floor((viewport.X - main.AbsoluteSize.X)/2))
        local newY = math.max(10, math.floor(viewport.Y * 0.08))
        pcall(function()
            TweenService:Create(main, TweenInfo.new(0.24, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position = UDim2.new(0, newX, 0, newY)}):Play()
        end)
    end)

    local lockPos = false
    local lockBtn = new("TextButton", {
        Parent = header, Text = "ðŸ”’", TextColor3 = Color3.fromRGB(200,200,200),
        BackgroundTransparency = 1, Position = UDim2.new(1,-210,0,8), Size = UDim2.new(0,48,0,36),
        Font = Enum.Font.GothamBold, TextSize = 16,
    })
    lockBtn.MouseButton1Click:Connect(function()
        lockPos = not lockPos
        lockBtn.Text = lockPos and "ðŸ”“" or "ðŸ”’"
        lockBtn.TextColor3 = lockPos and Color3.fromRGB(120,220,120) or Color3.fromRGB(200,200,200)
    end)

    -- edge unload "X" button (always visible)
    local unloadEdge = new("TextButton", {
        Parent = screenGui, Text = "âœ•", TextColor3 = Color3.fromRGB(255,255,255),
        BackgroundColor3 = Color3.fromRGB(30,30,30), Size = UDim2.new(0,36,0,36), Position = UDim2.new(1,-44,0.02,0),
        Font = Enum.Font.GothamBold, TextSize = 20, AutoButtonColor = true,
    })
    new("UICorner", {Parent=unloadEdge, CornerRadius = UDim.new(0,8)})
    local function unloadAll()
        if not loaded then return end
        loaded = false
        -- stop local features
        pcall(function() setNoclip(false) end)
        pcall(function() stopFly() end)
        pcall(function() setGod(false) end)
        -- disconnect tracked connections
        disconnectAll()
        -- destroy UI
        pcall(function() screenGui:Destroy() end)
        print("[exhub] Unloaded.")
    end
    unloadEdge.MouseButton1Click:Connect(function()
        unloadAll()
    end)

    -- search box
    local searchBox = new("TextBox", {
        Parent = header, Text = "", PlaceholderText = "Search commands or categories...",
        Size = UDim2.new(0.35, 0, 0, 28), Position = UDim2.new(0.6, 8, 0, 12),
        BackgroundColor3 = Color3.fromRGB(24,26,34), TextColor3 = Color3.fromRGB(230,230,230),
        Font = Enum.Font.Gotham, TextSize = 14, ClearTextOnFocus = false,
    })
    new("UICorner", {Parent=searchBox, CornerRadius=UDim.new(0,6)})

    -- Body layout (left categories, right content)
    local left = new("Frame", { Parent = main, Size = UDim2.new(0.22, -12, 1, -72), Position = UDim2.new(0,8,0,60), BackgroundTransparency = 1 })
    new("UICorner", {Parent=left, CornerRadius=UDim.new(0,8)})
    local leftBg = new("Frame", { Parent = left, Size = UDim2.new(1,0,1,0), BackgroundColor3 = Color3.fromRGB(22,26,34), BorderSizePixel = 0 })
    new("UICorner", {Parent=leftBg, CornerRadius=UDim.new(0,8)})
    local leftScroll = new("ScrollingFrame", {
        Parent = leftBg, Size = UDim2.new(1,-12,1,-12), Position = UDim2.new(0,6,0,6),
        BackgroundTransparency = 1, CanvasSize = UDim2.new(0,0,0,0), ScrollBarThickness = 8, VerticalScrollBarInset = Enum.ScrollBarInset.Always,
    })
    local leftList = new("UIListLayout", {Parent = leftScroll, Padding = UDim.new(0,8)})
    leftList.HorizontalAlignment = Enum.HorizontalAlignment.Center
    trackConn(leftList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        leftScroll.CanvasSize = UDim2.new(0,0,0,leftList.AbsoluteContentSize.Y + 12)
    end))

    -- right content
    local right = new("Frame", { Parent = main, Size = UDim2.new(0.76, -12, 1, -72), Position = UDim2.new(0.24, 8, 0, 60), BackgroundTransparency = 1 })
    local rightBg = new("Frame", { Parent = right, Size = UDim2.new(1,0,1,0), BackgroundColor3 = Color3.fromRGB(14,16,20), BorderSizePixel = 0 })
    new("UICorner", {Parent=rightBg, CornerRadius=UDim.new(0,8)})
    local rightScroll = new("ScrollingFrame", {
        Parent = rightBg, Size = UDim2.new(1,-12,1,-12), Position = UDim2.new(0,6,0,6),
        BackgroundTransparency = 1, CanvasSize = UDim2.new(0,0,0,0), ScrollBarThickness = 10, VerticalScrollBarInset = Enum.ScrollBarInset.Always,
    })
    local rightList = new("UIListLayout", {Parent = rightScroll, Padding = UDim.new(0,12)})
    trackConn(rightList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        rightScroll.CanvasSize = UDim2.new(0,0,0,rightList.AbsoluteContentSize.Y + 16)
    end))

    -- helpers for building controls inside a content container (parent should be rightScroll)
    local function makeLabel(parent, text)
        local lbl = new("TextLabel", {
            Parent = parent, Text = text or "", TextColor3 = Color3.fromRGB(220,220,220),
            BackgroundTransparency = 1, Size = UDim2.new(1,0,0,22),
            Font = Enum.Font.GothamBold, TextSize = 16, TextXAlignment = Enum.TextXAlignment.Left,
        })
        return lbl
    end

    local function makeSmallLabel(parent, text)
        return new("TextLabel", {
            Parent = parent, Text = text or "", TextColor3 = Color3.fromRGB(180,180,180),
            BackgroundTransparency = 1, Size = UDim2.new(1,0,0,18),
            Font = Enum.Font.Gotham, TextSize = 12, TextXAlignment = Enum.TextXAlignment.Left,
        })
    end

    local function makeButton(parent, text, callback, color)
        local frame = new("Frame", { Parent = parent, Size = UDim2.new(1,0,0,40), BackgroundTransparency = 1 })
        local btn = new("TextButton", {
            Parent = frame, Text = text or "Action", TextColor3 = Color3.fromRGB(255,255,255),
            BackgroundColor3 = color or Color3.fromRGB(40,120,220), Size = UDim2.new(1,0,1,0),
            Font = Enum.Font.GothamBold, TextSize = 14,
        })
        new("UICorner", {Parent=btn, CornerRadius=UDim.new(0,6)})
        trackConn(btn.MouseButton1Click:Connect(function() if callback then pcall(callback) end end))
        return frame, btn
    end

    local function makeToggle(parent, name, default, onToggle)
        local frame = new("Frame", { Parent = parent, Size = UDim2.new(1,0,0,36), BackgroundTransparency = 1 })
        local lbl = new("TextLabel", { Parent = frame, Text = name, TextColor3 = Color3.fromRGB(220,220,220),
            BackgroundTransparency = 1, Size = UDim2.new(1,-80,1,0), Position = UDim2.new(0,8,0,0),
            Font = Enum.Font.Gotham, TextSize = 14, TextXAlignment = Enum.TextXAlignment.Left })
        local toggle = new("TextButton", { Parent = frame, Text = default and "ON" or "OFF", Size = UDim2.new(0,68,0,26), Position = UDim2.new(1,-76,0,5),
            BackgroundColor3 = default and Color3.fromRGB(34,139,34) or Color3.fromRGB(120,30,30), TextColor3 = Color3.fromRGB(255,255,255),
            Font = Enum.Font.GothamBold, TextSize = 13 })
        new("UICorner", {Parent=toggle, CornerRadius=UDim.new(0,6)})
        local state = default and true or false
        trackConn(toggle.MouseButton1Click:Connect(function()
            state = not state
            toggle.Text = state and "ON" or "OFF"
            toggle.BackgroundColor3 = state and Color3.fromRGB(34,139,34) or Color3.fromRGB(120,30,30)
            if onToggle then pcall(onToggle, state) end
        end))
        return frame, toggle
    end

    local function makeSlider(parent, label, min, max, default, onChange)
        local container = new("Frame", { Parent = parent, Size = UDim2.new(1,0,0,66), BackgroundTransparency = 1 })
        makeSmallLabel(container, label)
        local barBg = new("Frame", {Parent = container, Size = UDim2.new(1, -120, 0, 18), Position = UDim2.new(0,8,0,26), BackgroundColor3 = Color3.fromRGB(36,36,36)})
        new("UICorner", {Parent=barBg, CornerRadius=UDim.new(0,6)})
        local relDefault = 0
        if max > min then relDefault = (default - min) / (max - min) end
        local fill = new("Frame", {Parent = barBg, Size = UDim2.new(math.clamp(relDefault,0,1),0,1,0), BackgroundColor3 = Color3.fromRGB(60,150,200)})
        new("UICorner", {Parent=fill, CornerRadius=UDim.new(0,6)})
        local valueLabel = new("TextLabel", { Parent = container, Text = tostring(default), BackgroundTransparency = 1, Size = UDim2.new(0,96,0,18), Position = UDim2.new(1,-100,0,24), TextColor3 = Color3.fromRGB(220,220,220), Font = Enum.Font.GothamBold, TextSize = 12 })
        local dragging = false
        trackConn(barBg.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = true
            end
        end))
        trackConn(barBg.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = false
            end
        end))
        trackConn(UserInputService.InputChanged:Connect(function(input)
            if not dragging then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                local rel = math.clamp((input.Position.X - barBg.AbsolutePosition.X) / math.max(barBg.AbsoluteSize.X, 1), 0, 1)
                fill.Size = UDim2.new(rel,0,1,0)
                local value = math.floor((min + (max-min)*rel) * 100) / 100
                valueLabel.Text = tostring(value)
                if onChange then pcall(onChange, value) end
            end
        end))
        -- setter
        local function set(v)
            v = tonumber(v) or default
            local rel = 0
            if max > min then rel = (v - min) / math.max((max-min),1) end
            fill:TweenSize(UDim2.new(math.clamp(rel,0,1),0,1,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.12, true)
            valueLabel.Text = tostring(math.floor(tonumber(v or default)*100)/100)
            if onChange then pcall(onChange, tonumber(valueLabel.Text)) end
        end
        set(default)
        return container, set
    end

    -- toggle some local features
    local noclipState = false
    local flyState = false
    local godState = false
    local infJumpState = false
    local flyConnections = {}
    local noclipConn

    -- helpers to operate locally (for client fallback / extra features)
    local function setNoclip(state)
        noclipState = state
        local char = player.Character
        if not char then return end
        if state then
            if noclipConn then safeDisconnect(noclipConn) end
            noclipConn = trackConn(RunService.Stepped:Connect(function()
                if not noclipState or not player.Character then return end
                for _, p in ipairs(player.Character:GetDescendants()) do
                    if p:IsA("BasePart") and p.CanCollide then p.CanCollide = false end
                end
            end))
        else
            if noclipConn then safeDisconnect(noclipConn); noclipConn = nil end
            if player.Character then
                for _, p in ipairs(player.Character:GetDescendants()) do
                    if p:IsA("BasePart") then p.CanCollide = true end
                end
            end
        end
    end

    -- fly (simple BodyVelocity + BodyGyro implementation)
    local flyForce, flyGyro, flyMoveVec = nil, nil, Vector3.new(0,0,0)
    local function startFly()
        local char = player.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        if flyForce then flyForce:Destroy() end
        if flyGyro then flyGyro:Destroy() end
        flyForce = Instance.new("BodyVelocity")
        flyForce.MaxForce = Vector3.new(1e5,1e5,1e5)
        flyForce.Velocity = Vector3.new(0,0,0)
        flyForce.Parent = hrp
        flyGyro = Instance.new("BodyGyro")
        flyGyro.MaxTorque = Vector3.new(1e5,1e5,1e5)
        flyGyro.Parent = hrp
        flyMoveVec = Vector3.new(0,0,0)
        -- key connections
        local conn1 = trackConn(UserInputService.InputBegan:Connect(function(input, gp)
            if gp then return end
            if input.KeyCode == Enum.KeyCode.W then flyMoveVec = Vector3.new(flyMoveVec.X, flyMoveVec.Y, -1) end
            if input.KeyCode == Enum.KeyCode.S then flyMoveVec = Vector3.new(flyMoveVec.X, flyMoveVec.Y, 1) end
            if input.KeyCode == Enum.KeyCode.A then flyMoveVec = Vector3.new(-1, flyMoveVec.Y, flyMoveVec.Z) end
            if input.KeyCode == Enum.KeyCode.D then flyMoveVec = Vector3.new(1, flyMoveVec.Y, flyMoveVec.Z) end
            if input.KeyCode == Enum.KeyCode.Space then flyMoveVec = Vector3.new(flyMoveVec.X, 1, flyMoveVec.Z) end
            if input.KeyCode == Enum.KeyCode.LeftShift then flyMoveVec = Vector3.new(flyMoveVec.X, -1, flyMoveVec.Z) end
        end))
        local conn2 = trackConn(UserInputService.InputEnded:Connect(function(input, gp)
            if gp then return end
            if input.KeyCode == Enum.KeyCode.W or input.KeyCode == Enum.KeyCode.S then flyMoveVec = Vector3.new(flyMoveVec.X, flyMoveVec.Y, 0) end
            if input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.D then flyMoveVec = Vector3.new(0, flyMoveVec.Y, flyMoveVec.Z) end
            if input.KeyCode == Enum.KeyCode.Space or input.KeyCode == Enum.KeyCode.LeftShift then flyMoveVec = Vector3.new(flyMoveVec.X, 0, flyMoveVec.Z) end
        end))
        table.insert(flyConnections, conn1)
        table.insert(flyConnections, conn2)

        local conn3 = trackConn(RunService.RenderStepped:Connect(function()
            local cam = workspace.CurrentCamera
            if not cam or not hrp then return end
            local look = cam.CFrame - cam.CFrame.Position
            local forward = look.LookVector
            local right = cam.CFrame.RightVector
            local up = Vector3.new(0,1,0)
            local moveSpeed = 80
            local vel = (forward * flyMoveVec.Z + right * flyMoveVec.X + up * flyMoveVec.Y) * moveSpeed
            if flyForce then flyForce.Velocity = vel end
            if flyGyro then flyGyro.CFrame = CFrame.new(hrp.Position, hrp.Position + cam.CFrame.LookVector) end
        end))
        table.insert(flyConnections, conn3)
    end

    local function stopFly()
        for _, c in ipairs(flyConnections) do
            if c then pcall(function() c:Disconnect() end) end
        end
        flyConnections = {}
        if flyForce then pcall(function() flyForce:Destroy() end) end
        if flyGyro then pcall(function() flyGyro:Destroy() end) end
        flyForce, flyGyro = nil, nil
    end

    -- infinite jump
    trackConn(UserInputService.JumpRequest:Connect(function()
        if infJumpState and player.Character then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                humanoid.Jump = true
            end
        end
    end))

    -- GOD mode auto-heal
    local godConn
    local function setGod(state)
        godState = state
        if state then
            if godConn then safeDisconnect(godConn) end
            godConn = trackConn(RunService.Heartbeat:Connect(function()
                local h = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
                if h and h.Health and h.MaxHealth and h.Health < h.MaxHealth then
                    h.Health = h.MaxHealth
                end
            end))
        else
            if godConn then safeDisconnect(godConn); godConn = nil end
        end
    end

    -- category system (left buttons)
    local categories = {}
    local currentCategory = nil

    local function clearRight()
        -- destroy children created for a category, keep UIListLayout intact
        for _, child in ipairs(rightScroll:GetChildren()) do
            if not child:IsA("UIListLayout") then
                child:Destroy()
            end
        end
    end

    -- convenience: create an action that sends to server (or local fallback)
    local function createAction(action, opt)
        opt = opt or {}
        return function(params)
            local payload = { action = action }
            if opt.valueKey then payload.value = params end
            if opt.positionKey then payload.position = params end
            if opt.directValue ~= nil then payload.value = opt.directValue end
            pcall(function() sendAction(payload) end)
        end
    end

    -- build categories + controls
    local function addCategory(name, builder)
        local btn = new("TextButton", {
            Parent = leftScroll, Text = name, TextColor3 = Color3.fromRGB(220,220,220),
            BackgroundColor3 = Color3.fromRGB(32,36,44), Size = UDim2.new(1,-12,0,44),
            Font = Enum.Font.GothamBold, TextSize = 14, AutoButtonColor = true,
        })
        new("UICorner", {Parent=btn, CornerRadius=UDim.new(0,8)})
        trackConn(btn.MouseButton1Click:Connect(function()
            -- deselect others
            for _, c in ipairs(leftScroll:GetChildren()) do
                if c:IsA("TextButton") then c.BackgroundColor3 = Color3.fromRGB(32,36,44) end
            end
            btn.BackgroundColor3 = Color3.fromRGB(50,110,220)
            clearRight()
            currentCategory = name
            builder(rightScroll)
        end))
        table.insert(categories, {name = name, button = btn, builder = builder})
    end

    -- Movement category
    addCategory("Movement", function(parent)
        makeLabel(parent, "Movement Controls")
        local _, walkSet = makeSlider(parent, "WalkSpeed", 0, 500, 16, function(v) sendAction({ action = "setWalkSpeed", value = v }) end)
        local _, jumpSet = makeSlider(parent, "JumpPower", 0, 500, 50, function(v) sendAction({ action = "setJumpPower", value = v }) end)
        local _, gravitySet = makeSlider(parent, "Gravity (world)", 0, 1000, Workspace.Gravity or 196, function(v) sendAction({ action = "setGravity", value = v }) end)
        makeButton(parent, "Teleport To Mouse", function()
            local mouse = player:GetMouse()
            local pos = mouse and mouse.Hit and mouse.Hit.Position
            if pos then sendAction({ action = "teleportToPosition", position = pos }) end
        end)
        makeButton(parent, "Teleport To Spawn", function() sendAction({ action = "teleportToSpawn" }) end)
        makeButton(parent, "Teleport To Player (self to them)", function()
            local prompt = tostring(player.Name) -- naive: teleport to first other player if present
            local others = Players:GetPlayers()
            for _, p in ipairs(others) do
                if p ~= player then
                    prompt = p.Name
                    break
                end
            end
            sendAction({ action = "teleportToPlayer", value = prompt })
        end)
        makeButton(parent, "Reset Character", function() sendAction({ action = "resetCharacter" }) end, Color3.fromRGB(200,80,80))
        makeButton(parent, "Copy Position", function()
            local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local pos = tostring(hrp.Position)
                pcall(function() setclipboard(pos) end)
                print("[exhub] Position copied:", pos)
            end
        end, Color3.fromRGB(120,120,120))
    end)

    -- Character category
    addCategory("Character", function(parent)
        makeLabel(parent, "Character Modifiers")
        local _, maxHealthSet = makeSlider(parent, "MaxHealth", 1, 5000, 100, function(v) sendAction({ action = "setMaxHealth", value = v }) end)
        makeButton(parent, "Heal (Full)", function() sendAction({ action = "heal" }) end)
        makeButton(parent, "Give Tool: TestTool", function() sendAction({ action = "giveTool", value = "TestTool" }) end)
        makeButton(parent, "Remove All Tools", function() sendAction({ action = "removeTools" }) end, Color3.fromRGB(180,60,60))
        makeButton(parent, "Anchored: ON (makes character immobile)", function() sendAction({ action = "setAnchored", value = true }) end, Color3.fromRGB(180,180,60))
        makeButton(parent, "Anchored: OFF", function() sendAction({ action = "setAnchored", value = false }) end, Color3.fromRGB(60,180,60))
        local _, transSet = makeSlider(parent, "Character Transparency (0-1)", 0, 1, 0, function(v) sendAction({ action = "setTransparency", value = v }) end)
        makeButton(parent, "Sit", function()
            local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then humanoid.Sit = true end
        end)
        makeButton(parent, "Stand", function()
            local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then humanoid.Sit = false end
        end)
        makeButton(parent, "SuperJump (impulse)", function()
            local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.Velocity = hrp.Velocity + Vector3.new(0, 150, 0)
            end
        end)
    end)

    -- Tools category
    addCategory("Tools", function(parent)
        makeLabel(parent, "Tools & Inventory")
        makeButton(parent, "Give Sword (Server Storage: Sword)", function() sendAction({ action = "giveTool", value = "Sword" }) end)
        makeButton(parent, "Give Gun (Server Storage: Gun)", function() sendAction({ action = "giveTool", value = "Gun" }) end)
        makeButton(parent, "Give TestTool", function() sendAction({ action = "giveTool", value = "TestTool" }) end)
        makeButton(parent, "Remove All Tools", function() sendAction({ action = "removeTools" }) end, Color3.fromRGB(190,70,70))
        makeButton(parent, "Equip First Backpack Tool", function()
            local backpack = player:FindFirstChild("Backpack")
            if backpack then
                for _, item in ipairs(backpack:GetChildren()) do
                    if item:IsA("Tool") then
                        if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
                            pcall(function() player.Character:FindFirstChildOfClass("Humanoid"):EquipTool(item) end)
                        end
                        break
                    end
                end
            end
        end)
    end)

    -- World category
    addCategory("World", function(parent)
        makeLabel(parent, "World / Server settings (self-only where relevant)")
        local _, gravitySet = makeSlider(parent, "Gravity (world)", 0, 1000, Workspace.Gravity or 196, function(v) sendAction({ action = "setGravity", value = v }) end)
        makeButton(parent, "Gravity Low (50)", function() sendAction({ action = "setGravity", value = 50 }) end, Color3.fromRGB(80,140,200))
        makeButton(parent, "Gravity Normal (196)", function() sendAction({ action = "setGravity", value = 196 }) end, Color3.fromRGB(80,200,140))
        makeButton(parent, "Print Nearby Objects", function()
            local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local out = {}
                for _, obj in ipairs(Workspace:GetDescendants()) do
                    if obj:IsA("BasePart") and (obj.Position - hrp.Position).Magnitude < 100 then
                        table.insert(out, obj.Name)
                    end
                end
                print("[exhub] Nearby parts:", table.concat(out, ", "))
            end
        end)
    end)

    -- Camera category
    addCategory("Camera", function(parent)
        makeLabel(parent, "Camera / View")
        makeButton(parent, "Set FOV: 70", function() local cam = workspace.CurrentCamera; if cam then cam.FieldOfView = 70 end end)
        makeButton(parent, "Set FOV: 90", function() local cam = workspace.CurrentCamera; if cam then cam.FieldOfView = 90 end end)
        makeButton(parent, "Set FOV: 120", function() local cam = workspace.CurrentCamera; if cam then cam.FieldOfView = 120 end end)
        makeButton(parent, "Reset FOV", function() local cam = workspace.CurrentCamera; if cam then cam.FieldOfView = 70 end end)
        makeButton(parent, "Lock Camera to Character", function()
            local cam = workspace.CurrentCamera
            cam.CameraSubject = player.Character
            cam.CameraType = Enum.CameraType.Custom
        end)
        makeButton(parent, "Free Camera (Scriptable)", function()
            local cam = workspace.CurrentCamera
            cam.CameraType = Enum.CameraType.Scriptable
        end)
    end)

    -- Utilities category
    addCategory("Utilities", function(parent)
        makeLabel(parent, "Utilities")
        makeButton(parent, "Copy Position (clipboard)", function()
            local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local pos = tostring(hrp.Position)
                pcall(function() setclipboard(pos) end)
                print("[exhub] Position copied:", pos)
            end
        end)
        makeButton(parent, "Teleport to Workspace Origin (0,5,0)", function() sendAction({ action = "teleportToPosition", position = Vector3.new(0,5,0) }) end)
        makeButton(parent, "Print Player List", function()
            local list = {}
            for _, p in ipairs(Players:GetPlayers()) do table.insert(list, p.Name) end
            print("[exhub] Players:", table.concat(list, ", "))
        end)
        makeButton(parent, "Server Time (print)", function() print("[exhub] Server time (os):", os.time()) end)
        makeButton(parent, "Show RemoteEvent Status", function()
            print("[exhub] RemoteEvent present:", tostring(canUseRemote()))
        end)
    end)

    -- Local Hacks (client-only)
    addCategory("Local Hacks", function(parent)
        makeLabel(parent, "Local-only (client) features")
        local noclipFrame, noclipToggle = makeToggle(parent, "Noclip", false, function(state) setNoclip(state) end)
        local flyFrame, flyToggle = makeToggle(parent, "Fly (WASD+Space+Shift)", false, function(state)
            flyState = state
            if state then startFly() else stopFly() end
        end)
        local godFrame, godToggle = makeToggle(parent, "God Mode (auto-heal)", false, function(state) setGod(state) end)
        local infFrame, infToggle = makeToggle(parent, "Infinite Jump", false, function(state) infJumpState = state end)
        makeButton(parent, "Spin Character (6s)", function()
            local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            local rot = Instance.new("BodyAngularVelocity")
            rot.MaxTorque = Vector3.new(1e6,1e6,1e6)
            rot.AngularVelocity = Vector3.new(0,20,0)
            rot.Parent = hrp
            delay(6, function() if rot and rot.Parent then rot:Destroy() end end)
        end)
        makeButton(parent, "Invisible (character)", function()
            local ch = player.Character
            if ch then
                for _, d in ipairs(ch:GetDescendants()) do
                    if d:IsA("BasePart") then d.Transparency = 1 end
                    if d:IsA("Decal") then d.Transparency = 1 end
                end
            end
        end)
        makeButton(parent, "Visible (character)", function()
            local ch = player.Character
            if ch then
                for _, d in ipairs(ch:GetDescendants()) do
                    if d:IsA("BasePart") then d.Transparency = 0 end
                    if d:IsA("Decal") then d.Transparency = 0 end
                end
            end
        end)
        makeButton(parent, "Freeze Character (disable controls)", function()
            local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then humanoid.PlatformStand = true end
        end, Color3.fromRGB(200,120,80))
        makeButton(parent, "Unfreeze Character", function()
            local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then humanoid.PlatformStand = false end
        end, Color3.fromRGB(80,200,120))
    end)

    -- default open first category
    if #categories > 0 then
        categories[1].button:CaptureFocus()
        categories[1].button.BackgroundColor3 = Color3.fromRGB(50,110,220)
        categories[1].builder(rightScroll)
    end

    -- search behavior: simple substring filter on buttons
    trackConn(searchBox.Changed:Connect(function()
        local text = tostring(searchBox.Text):lower()
        for _, c in ipairs(categories) do
            local visible = text == "" or c.name:lower():find(text)
            c.button.Visible = visible
        end
    end))

    -- desktop toggle (keyboard)
    trackConn(UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == CONFIG.ToggleKey then
            if not isAdminClient() then
                warn("desktop: not admin")
                return
            end
            main.Visible = not main.Visible
        end
    end))

    -- mobile-friendly toggle
    if UserInputService.TouchEnabled then
        local mobileToggle = new("TextButton", {
            Parent = screenGui, Text = "â‰¡", TextColor3 = Color3.fromRGB(255,255,255),
            BackgroundColor3 = Color3.fromRGB(30,30,30), Size = UDim2.new(0,56,0,56), Position = UDim2.new(0.03,0,0.88,0),
            Font = Enum.Font.GothamBold, TextSize = 28, AutoButtonColor = true,
        })
        new("UICorner", {Parent=mobileToggle, CornerRadius=UDim.new(0,10)})
        trackConn(mobileToggle.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
                if not isAdminClient() then
                    warn("mobile: not admin")
                    return
                end
                main.Visible = not main.Visible
            end
        end))
    end

    -- default visibility
    main.Visible = isAdminClient()

    -- notify connection status
    if canUseRemote() then
        print("[exhub] Connected to server RemoteEvent:", event:GetFullName())
    else
        print("[exhub] RemoteEvent not found. Client fallback is", tostring(CONFIG.AllowClientFallback) .. ".")
    end

    -- ensure character handlers reapply states on respawn
    trackConn(player.CharacterAdded:Connect(function(char)
        -- reapply noclip if enabled
        if noclipState then setNoclip(true) end
        if flyState then startFly() end
        if godState then setGod(true) end
    end))

    -- lightweight heartbeat: kept for future improvements
    spawn(function()
        while loaded do
            wait(0.5)
            -- left as a placeholder to sync values if desired
        end
    end)

    -- Make window draggable (mouse & touch)
    do
        local dragging = false
        local dragStart = Vector2.new()
        local startPos = Vector2.new()
        local function onInputBegan(input)
            if lockPos then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                local mousePos = input.Position
                local absPos = main.AbsolutePosition
                local absSize = main.AbsoluteSize
                -- start dragging only if clicking header area
                local headerAbsPos = header.AbsolutePosition
                local headerAbsSize = header.AbsoluteSize
                if mousePos.X >= headerAbsPos.X and mousePos.X <= headerAbsPos.X + headerAbsSize.X and
                   mousePos.Y >= headerAbsPos.Y and mousePos.Y <= headerAbsPos.Y + headerAbsSize.Y then
                    dragging = true
                    dragStart = mousePos
                    startPos = Vector2.new(absPos.X, absPos.Y)
                end
            end
        end
        local function onInputChanged(input)
            if not dragging then return end
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                local delta = input.Position - dragStart
                local newX = math.clamp(startPos.X + delta.X, 8, (workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize.X or 1920) - main.AbsoluteSize.X - 8)
                local newY = math.clamp(startPos.Y + delta.Y, 8, (workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize.Y or 1080) - main.AbsoluteSize.Y - 8)
                main.Position = UDim2.new(0, newX, 0, newY)
            end
        end
        local function onInputEnded(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragging = false
            end
        end
        trackConn(UserInputService.InputBegan:Connect(onInputBegan))
        trackConn(UserInputService.InputChanged:Connect(onInputChanged))
        trackConn(UserInputService.InputEnded:Connect(onInputEnded))

        -- center the window properly once sizes are known
        spawn(function()
            for i=1,60 do
                wait(0.02)
                if main.AbsoluteSize.X > 10 then break end
            end
            local vp = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1280,720)
            local newX = math.max(8, math.floor((vp.X - main.AbsoluteSize.X)/2))
            local newY = math.max(8, math.floor(vp.Y * 0.08))
            main.Position = UDim2.new(0, newX, 0, newY)
        end)
    end

    -- ensure we can gracefully unload via global (useful for reloading scripts)
    if _G and _G.ExHubUnload then
        -- If previous loader exposed unload, call it before replacing
        pcall(function() _G.ExHubUnload() end)
    end
    _G.ExHubUnload = unloadAll

    -- done
end
